# SDK 使用说明文档

# 一、目录结构

```plain
src
+---main
|   \---java
|       +---com
|       |   \---safeheron
|       |       \---stellar
|       |           +---core
|       |           |       RpcClient.java              连接 Stellar RPC-API 的客户端
|       |           |       
|       |           +---entity
|       |           |       AddressIdentifier.java      由 hex 格式公钥转为账户地址和合约地址
|       |           |       AddressVerify.java          地址验证结果
|       |           |       Balance.java                余额
|       |           |       BlockHeader.java            区块（也称账本）信息
|       |           |       BlockTxnsVO.java            某一区块(Stellar中也叫账本)包含的所有交易
|       |           |       Currency.java               币种
|       |           |       Fee.java                    预估的手续费
|       |           |       NeedSignSignatureDTO.java   待签名的 signature 和公钥
|       |           |       NeedSignTransactionDTO.java 待签名的交易信息
|       |           |       PublicKeyIdentifier.java    公钥
|       |           |       SignedSignatureDTO.java     已签名的 signature 和公钥
|       |           |       SignedTransactionDTO.java   已签名的交易, 可以提交上链
|       |           |       TransactionVO.java          链上查询的交易
|       |           |       
|       |           \---util
|       |                   TransactionUtil.java        交易相关工具类
|       |                   
|       \---org
|           \---stellar
|               \---sdk 官方SDK只列出需要关注的包和类
|                   |   Account.java					账户模型
|                   |   Asset.java						资产, 包含 Native 币和 Token 币
|                   |   AssetTypeCreditAlphaNum.java	Token 币抽象类
|                   |   AssetTypeCreditAlphaNum12.java	Token 币
|                   |   AssetTypeCreditAlphaNum4.java	Token 币
|                   |   AssetTypeNative.java			Native 币
|                   |   LedgerBound.java				账本范围, 用于设置交易预条件, 翻页参数等
|                   |   Memo.java						Memo 抽象类
|                   |   MemoHash.java					hash 类型的 Memo
|                   |   MemoHashAbstract.java			
|                   |   MemoId.java						Id 类型的 Memo
|                   |   MemoNone.java					空类型的 Memo
|                   |   MemoReturnHash.java				ReturnHash 类型的 Memo
|                   |   MemoText.java					Text 类型的 Memo
|                   |   Network.java					Stellar 网络标识, 例如测试或生产
|                   |   TimeBounds.java					时间范围, 用于设置交易预条件
|                   |   Transaction.java				交易
|                   |   TransactionBuilder.java			构造交易可用的 Builder
|                   |   TransactionBuilderAccount.java	账户模型抽象类
|                   |   TransactionPreconditions.java	交易预条件
|                   |   Util.java						工具类, 主要用于 Hex 格式转换, 补位等功能
|                   |   ... 其余类 ...
|                   |           
|                   +---exception 自定义运行时异常
|                   |       AccountNotFoundException.java	账户不存在异常
|                   |       ... 其余类 ...
|                   |           
|                   +---operations 交易可使用的操作
|                   |       InvokeHostFunctionOperation.java	调用合约用的操作
|                   |       PaymentOperation.java				转账操作
|                   |       ... 其余类 ...
|                   |       
|                   +---... 其余包...
|                           
\---test
    +---java
    |   +---com
    |   |   \---safeheron
    |   |       \---stellar
    |   |           +---core
    |   |           |       RpcClientTest.java
    |   |           |       
    |   |           \---entity
    |   |                   AddressIdentifierTest.java
    |   |                   TransactionTest.java
    |   |                   
    |   \---org
    |       \---stellar
    |           \---sdk
    |               |   AccountTest.java
    |               |   AssetTest.java
    |               |   KeyPairTest.java
    |               |   LedgerBoundsTest.java
    |               |   MemoTest.java
    |               |   TimeBoundsTest.java
    |               |   TransactionBuilderTest.java
    |               |   TransactionPreconditionsTest.java
    |               |   TransactionTest.java
    |               |       
    |               +---operations
    |               |       InvokeHostFunctionOperationTest.java
    |               |       PaymentOperationTest.java
    |               |       ... 其余类 ...
    |               |
    |               +---... 其余包...
    |                       
    \---resources mock测试所需的数据
```



# 二、SDK 实现方法

## 2.1 账户相关

### 2.1.1 生成地址（公钥生成地址列表【如果有多个地址类型】）

生成地址：

```java
com.safeheron.stellar.entity.AddressIdentifier
	
    /** 原始公钥值 (未转换, 十六进制格式) */
    private final String hexPublicKey;
    
    /** Stellar 地址值 G... or C... */
    private final String stellarAddress;
    
    /** 地址类型 */
    private final AddressType type;

    /**
     * 通过 Hex 格式公钥创建地址
     * @param publicKeyIdentifier 公钥
     * @return 多种类型的地址
     */
	public static List<AddressIdentifier> derive(PublicKeyIdentifier publicKeyIdentifier);
```

公钥：

```java
com.safeheron.stellar.entity.PublicKeyIdentifier

	/** 32 bytes 公钥的十六进制字符串 */
    String hexBytes;

    /** 公钥类型 */
    CurveType curveType;
```

### 2.1.2 查询余额（Native币种余额、 Token币种余额）

通过客户端查询余额：

```java
com.safeheron.stellar.core.RpcClient
    
    /**
     * 获取某一账户指定币种的余额
     * @param accountAddress 账户地址
     * @param currencies 指定的币种
     * @return 返回某一账户指定币种的余额
     */
    public List<Balance> getBalances(String accountAddress, List<Currency> currencies)
```

余额：

```java
com.safeheron.stellar.entity.Balance
    
    /** 余额, 单位是最小单位例如 native 币是 1 Stroop = 0.0000001 XLM, token 币也是 0.0000001 */
    Long value;

    /** 币种 */
    Currency currency;
```

币种（Asset 在后续单独说明）：

```java
com.safeheron.stellar.entity.Currency

	/** 标识符 */
    String symbol;

    /** 小数位 */
    Integer decimals;

    /** token 合约地址或 Stellar 发行地址，主链币为常量“NATIVE” */
    String tokenIdentifier;

    /** Stellar 资产, 分为 native 币和 token 币 */
    Asset asset;
```

### 2.1.3 查询地址信息

如地址类型，是否是合约地址，地址格式合法性等。

离线验证地址格式：

```java
com.safeheron.stellar.entity.AddressIdentifier
    
    /**
     * 验证地址格式, 离线
     * @param address Stellar 地址字符串，G..., C..., M...
     * @return AddressVerify 地址验证结果 (并不验证链上是否存在)
     */
    public static AddressVerify validAddressFormat(AddressIdentifier address);
```

链上验证地址是否存在：

```java
com.safeheron.stellar.core.RpcClient
    
    /**
     * 链上验证地址是否存在
     * @param address 地址
     * @return 链上验证地址的结果
     */
    public AddressVerify validAddressOnChain(AddressIdentifier address);
```

验证地址结果：

```java
com.safeheron.stellar.entity.AddressVerify
    
    /** 地址格式是否正确，如果不正确不用再校验地址是否真实存在于链上 */
    boolean isFormatCorrect;

    /** 是否 Stellar account 账户地址 (G...)  */
    boolean isAccountAddress;

    /** 是否 WASM contract (也叫 Soroban contract) 合约地址 (C...) */
    boolean isContractAddress;

    /** 是否 Muxed Account (并不存在于链上, 为了便捷和标准化而被嵌入到协议中) 多路复用账户地址 (M...) */
    boolean isMuxedAccountAddress;

    /** 地址在链上是否存在 */
    boolean isExistOnChain;
```

## 2.2 交易相关

### 2.2.1 构造交易，传入基础信息，返回待签名的交易 hash

通过工具类从构造的交易中获取待签名的交易 hash（Transaction 在后续单独说明）：

```java
com.safeheron.stellar.util.TransactionUtil
    /**
     * 获取未签名交易
     * @param publicKeys 签名signer对应的公钥，Hex格式，若涉及多签则list中存入多个
     * @return 未签名交易的序列化字符串, 待签名的txHash字符串, 签名signer对应的公钥
     * @throws IOException
     */
    public static NeedSignTransactionDTO getUnsignedTransaction(Transaction transaction, List<String> publicKeys)
```

待签名的交易信息：

```java
com.safeheron.stellar.entity.NeedSignTransactionDTO
    
    /** 未签名交易序列化, Hex 格式 */
    String unsignedTransaction;

    /** 待签名数据, 若存在多签则有多个 */
    List<NeedSignSignatureDTO> unsignedSignatures;
```

待签名的 signature 和公钥：

```java
com.safeheron.stellar.entity.NeedSignSignatureDTO
    
    /** 交易的 hash 值, Hex 格式 */
    String txHash;

    /** 需要此地址签名, From 地址, Hex 格式 */
    String address;
```

### 2.2.2 构造交易，传入原始交易+签名的交易 hash，返回上链的交易 hex

通过原始交易和签名后的交易 hash 构造出可以提交上链的交易串：

```java
com.safeheron.stellar.util.TransactionUtil
    
    /**
     * 
     * @param unsignedTransaction 未签名交易序列化, Hex格式
     * @param signedSigDTOs 已签名的txHash和对应的公钥
     * @param network 测试网或公网
     * @return SignedTransactionDTO 包含离线计算的txHash和可提交上链的已签名序列化交易
     * @throws IOException
     */
    public static SignedTransactionDTO getSignedTransaction(String unsignedTransaction, 
                                                            List<SignedSignatureDTO> signedSigDTOs, 
                                                            Network network)

```

已签名的 signature 和公钥：

```java
com.safeheron.stellar.entity.SignedSignatureDTO
    
    /** 签名完成后的数据(hash), Hex格式 */
    String signedTxHash;

    /** 签名公钥, Hex格式 */
    String publickKey;
```

已签名的交易, 可以提交上链：

```java
com.safeheron.stellar.entity.SignedTransactionDTO
    
    /** 离线计算, 交易 txHash, Hex 格式 */
    String txHash;

    /** 已经签名交易. 可以提交上链 */
    String signedTransaction;
```

### 2.2.3 提交交易，广播上链

提交交易：

```java
com.safeheron.stellar.core.RpcClient
    
    /**
     * 提交交易上链，Soroban-RPC 会 simply validates and enqueues the transaction，客户端需要再通过
     * SorobanServer#getTransaction 进一步查询交易状态，例如从 PENDING 转为 SUCCESS
     *
     * @param signedTransaction 已签名序列化后的交易
     * @return 返回txHash,和离线计算返回的txHash相同
     */
    public String submit(String signedTransaction);
```

### 2.2.4 根据 txHash 查询交易

根据 txHash 查询交易：

```java
com.safeheron.stellar.core.RpcClient
    
    /**
     * 根据 txHash 获取指定交易
     * @param txHash 交易 hash, Hex 格式
     * @param network Stellar 网络标识 {@link Network}
     * @return TransactionVO
     */
    public TransactionVO getTransactionReceipt(String txHash, Network network)
```

链上查询的交易：

```java
com.safeheron.stellar.entity.TransactionVO
    
        /**
     * 交易状态
     * ref: @see <a href="https://developers.stellar.org/docs/data/rpc/api-reference/methods/getTransaction" target="_blank">getTransaction documentation</a>
     */
    TransactionStatus status;

    /** 交易 Hash */
    String txHash;

    /** Stellar RPC 处理本次请求时的最新账本序号 */
    Long latestLedger;

    /** Stellar RPC 处理本次请求时的最新账本的关闭时间 unix timestamp */
    Long latestLedgerCloseTime;

    /** Stellar RPC 处理本次请求时的最早账本序号 */
    Long oldestLedger;

    /** Stellar RPC 处理本次请求时的最早账本的关闭时间 unix timestamp */
    Long oldestLedgerCloseTime;

    /**
     * 只有 status 为 SUCCESS 或 FAILED 时才有值
     * 该交易在账本所有交易中的索引
     */
    Integer applicationOrder;

    /** 交易手续费是否 fee bumped */
    Boolean feeBump;

    /**
     * base64 编码的已序列化交易
     * The field can be parsed as {@link org.stellar.sdk.xdr.TransactionEnvelope} object.
     */
    String envelopeXdr;

    /**
     * 只有 status 为 SUCCESS 或 FAILED 时才有值
     * The field can be parsed as {@link org.stellar.sdk.xdr.TransactionResult} object.
     */
    String resultXdr;

    /** The field can be parsed as {@link org.stellar.sdk.xdr.TransactionMeta} object. */
    String resultMetaXdr;

    /** 此交易所在的账本序号 */
    Long ledger;

    /** 此交易被写入账本的时间 unix timestamp */
    Long createdAt;

    /** 手续费 */
    Long gasFee;

    /** 链上执行失败的错误信息, 从 resultXdr 解析得到*/
    String chainMsg;

    /** 解析出 from 地址 */
    String fromAddress;

    /** 如果包含 payment 操作, 解析出 PaymentOperation 包含目的地址, 交易币种和金额 */
    List<PaymentOperation> payments;
```

### 2.2.5 获取手续费

非合约调用交易预估手续费：

```java
com.safeheron.stellar.core.RpcClient
    
    /**
     * 预估非调用合约的交易的手续费, 包含基础手续费和总体手续费
     * @param numOfOP 交易中操作的数量
     * @return Fee 基础手续费和手续费总和
     */
    public Fee getNetworkFee(int numOfOP)
```

合约调用交易预估手续费：

```java
com.safeheron.stellar.core.RpcClient

    /**
     * 预估调用合约的交易的手续费, 包含基础手续费和总体手续费
     * @param transaction 交易对象, 传入此方法的 transaction 对象无需签名.
     * @return Fee 基础手续费和手续费总和
     */
    public Fee getNetworkFee(Transaction transaction)
```

手续费：

```java
com.safeheron.stellar.entity.Fee
    
    /** 预估的调用合约的基础费用, 单位是最小单位 1 Stroop = 0.0000001 XLM */
    Long preSorobanInclusionFee;

    /** 预估的非调用合约的基础费用, 单位是最小单位 1 Stroop = 0.0000001 XLM */
    Long preInclusionFee;

    /** 预估的费用总和, 单位是最小单位 1 Stroop = 0.0000001 XLM */
    Long totalFee;
```

## 3.3 区块相关

### 3.3.1 根据高度查询区块信息

如块头、 上一个区块hash、交易列表，每6秒查一下所有的账本，给出账本中的所有交易：

```java
com.safeheron.stellar.core.RpcClient

	/**
     * 获取指定账本中的交易
     * @param blockHeight 账本序号 ledger sequence
     * @param page 翻页参数
     * @param network Stellar 网络标识 {@link Network}
     * @return BlockTxnsVO
     */
    public BlockTxnsVO getTransctionsByblock(String blockHeight, GetTransactionsRequest.PaginationOptions page, Network network) 
```

区块信息：

```java
com.safeheron.stellar.entity.BlockTxnsVO
    
    /** 在 Stellar 也称 ledger sequence */
    Long blockNum;

    /** 当前块 Hash */
    String blockHash;

    /** 上个区块hash，如果不方便可以不用 */
    String paretHash;

    /** 区块时间 */
    Long timeStamp;

    /** 解析出来的交易集合 */
    List<TransactionVO> transactions;
```

### 3.3.2 查询最新高度

查询最新的高度（序号最新的账本）：

```java
com.safeheron.stellar.core.RpcClient

	/**
     * 查询最新高度
     * @return BlockHeader, 包含最新账本序号, 账本 hash, 账本关闭时间, 前一个账本 hash
     */
    public BlockHeader getLatestBlock();
```

最新区块头的信息

```java
com.safeheron.stellar.entity.BlockHeader

    /** 在 Stellar 也称 ledger sequence */
    String height;

    /** 在 Stellar 也称 ledger hash */
    String blockHash;

    /** 在 Stellar 也称 ledger close time */
    Long timeStamp;

    /** 在 Stellar 也称 previous ledger hash */
    String parenBlockHash;
```

# 三、Stellar 官方 SDK 需关注的部分

## 3.1 账户相关

### 3.1.1 Account 账户

Account 可以通过如下方法获取

```java
com.safeheron.stellar.core.RpcClient
    
  /**
   * Fetch a minimal set of current info about a Stellar account. Needed to get the current sequence
   * number for the account, so you can build a successful transaction with {@link
   * TransactionBuilder}.
   *
   * @param address The address of the account to load, muxed accounts are supported.
   * @return An {@link Account} object containing the sequence number and current state of the
   *     account.
   */
  public TransactionBuilderAccount getAccount(String address) 
```

Account 主要包含 Stellar 账户地址（G...）和已使用的 sequenceNumber

```java
org.stellar.sdk.Account
    
    /** The account ID. */
    @NonNull private final String accountId;

    /** The sequence number of the account. */
    @NonNull private Long sequenceNumber;
```

## 3.2 交易相关

### 3.2.1 PaymentOperation 转账操作

在 Stellar 一个交易 Transaction 是由一组操作 Operation 构成的，其中最常见的就是转账操作。Stellar 中的转账操作不仅可以实现 Native 币 XLM 的转账，也可以实现 Token 币（如 USDC）的转账。

#### 1、PaymentOperation 模型

可以看到主要包含

- 目的地址 destination：Stellar 账户地址 G...

- 资产 asset：在 Stellar 中 Native 币和 Token 币都统称资产
- 转账金额 amount：精度统一为 0.0000001

```java
org.stellar.sdk.operations.PaymentOperation

    /** Account that receives the payment. */
    @NonNull private final String destination;

    /** Asset to send to the destination account. */
    @NonNull private final Asset asset;

    /** Amount of the asset to send. (max of 7 decimal places). */
    @NonNull private final BigDecimal amount;
```

#### 2、如何构造一个 PaymentOperation 转账操作

Stellar 官方 SDK 基本都采用建造者的设计模式，以转账 Native 币为例

```java
// 创建转账操作
PaymentOperation paymentOperation = PaymentOperation
    .builder()
    .destination(target.getAccountId())
    .asset(new AssetTypeNative())
    .amount(new BigDecimal("0.0000001")) // 1.0000000 XLM * 10^-7 = 0.0000001 XLM = 1 Stroop
    .build();
```

### 3.2.2 Transaction 交易对象

Transaction 是由一组操作 Operation 构成的，同时还包含手续费，签名等关键信息

#### 1、Transaction 模型

可以看到主要包含：

- 手续费：单位是 1 stroop = 0.0000001 XLM
- 交易发起账户（源账户）地址：Stellar 账户地址 G...
- 账户的下一个可用的 sequenceNumber：一般获取到账户对象之后，调用 `sourceAccount.getIncrementedSequenceNumber()` 即可获得
- 一组操作
- Memo：可选
- TransactionPreconditions：交易预条件
- SorobanTransactionData：调用合约所涉及的资源，可通过 `RpcClient.prepareTransaction(transaction)` 方法构造而来。

```java
org.stellar.sdk.Transaction
    
    /** Max fee paid for transaction in stroops (1 stroop = 0.0000001 XLM). */
    @Getter private final long fee;

    /** The source account for this transaction. */
    @Getter @NonNull private final String sourceAccount;

    /** The sequence number of the account creating this transaction. */
    @Getter private final long sequenceNumber;

    /** Operations included in the transaction. */
    @Getter @NonNull private final Operation[] operations;

    /** Memo attached to the transaction. */
    @Getter @NonNull private final Memo memo;

    /** The preconditions for the transaction. */
    @Getter private final TransactionPreconditions preconditions;

    /** The Soroban data for the transaction. */
    @Getter private final SorobanTransactionData sorobanData;
```

#### 2、如何构造一个 Transaction 交易对象

官方 SDK 建议使用建造者模式创建 Transaction 交易对象。

对于非调用合约的交易：

```java
// 已获取好的源账户
TransactionBuilderAccount account = server.getAccount(source.getAccountId());
// 创建转账操作
PaymentOperation paymentOperation = PaymentOperation
    .builder()
    .destination(target.getAccountId())
    .asset(new AssetTypeNative())
    .amount(new BigDecimal("0.0000001")) // 1.0000000 XLM
    .build();
// 创建预条件,
TransactionPreconditions preconditions = TransactionPreconditions.builder().timeBounds(new TimeBounds(0, 0)).build();

// 创建交易对象
Transaction transaction = new Transaction(account.getAccountId(),
                                          Transaction.MIN_BASE_FEE * 1, // 真实生产环境需要通过手续费预估接口计算
                                          account.getIncrementedSequenceNumber(),
                                          new Operation[]{paymentOperation},
                                          null, // 不传入 Memo 默认是 MemoNone 类型
                                          preconditions,
                                          null, // 并不是合约调用，无需传入 SorobanTransactionData 对象
                                          Network.TESTNET);
// 可以不进行+1操作，下次交易重新从链上获取最新账户信息
account.incrementSequenceNumber();
```

对于合约调用的交易：

```java
// 已获取好的源账户
TransactionBuilderAccount account = server.getAccount(source.getAccountId());

// 创建合约调用的操作
List<SCVal> contractArgs = new ArrayList<SCVal>();
contractArgs.add(Scv.toString("ZSY"));
InvokeHostFunctionOperation operation =
    InvokeHostFunctionOperation.invokeContractFunctionOperationBuilder(
    contractAddress, "hello", contractArgs)
    .build();

// 创建预条件,
TransactionPreconditions preconditions = TransactionPreconditions.builder().timeBounds(new TimeBounds(0, 0)).build();

// 创建交易对象
Transaction transaction = new Transaction(account.getAccountId(),
                                          Transaction.MIN_BASE_FEE * 1, // 真实生产环境需要通过手续费预估接口计算 Inclusion Fee 并传入
                                          sourceAccount.getIncrementedSequenceNumber(),
                                          new Operation[]{operation},
                                          null, // 不传入 Memo 默认是 MemoNone 类型
                                          preconditions,
                                          null, // 是合约调用则需要传入，但可通过 prepareTrasaction 完成构造
                                          Network.TESTNET);
// 由于是合约调用，需要通过 prepareTransaction 完成手续费 ResourceFee 部分预估和 SorobanTransactionData 构造
transaction = server.prepareTransaction(transaction);

// 可以不进行+1操作，下次交易重新从链上获取最新账户信息
account.incrementSequenceNumber();
```



### 3.2.3 Memo

目前 Memo 的[类型](https://developers.stellar.org/docs/learn/encyclopedia/transactions-specialized/memos#memo-content-examples)有4种，分别是：

- MEMO_TEXT： A string encoded using either ASCII or UTF-8, up to 28-bytes long. 如果是中文 UTF-8 编码只能存 9 个汉字, 绝大多数场景使用此类型
- MEMO_ID: A 64-bit unsigned integer. 在 [Pooled Accounts](https://developers.stellar.org/docs/learn/encyclopedia/transactions-specialized/pooled-accounts-muxed-accounts-memos#pooled-accounts) 中通过此类型区分不同的账户, 未来会使用 Muxed Accounts 替代, 未来可能会废弃.
- MEMO_HASH: A 32-byte hash.  未来可能用于关联其他数据, 内部路由信息等.
- MEMO_RETURN: A 32-byte hash intended to be interpreted as the hash of the transaction the sender is refunding. 作为某笔交易的退款或报销的标识.

一般的构造方式都是通过